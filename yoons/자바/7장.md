
## 클래스의 네임스페이스
클래스의 네임스페이스는 클래스 내부에서 정의된 속성과 메서드의 이름을 저장하고 관리하는 공간이다.
네임스페이스는 이름과 해당 이름에 바인딩된 객체(값)을 연결하는 역할을 한다.
자바에서는 패키지 내에 해당 클래스의 이름을 정의함으로서 이름 충돌을 방지한다.


## 상속시에 네임스페이스
자식 클래스가 부모 클래스를 상속받으면, 자식 클래스의 정의 내에서 정의되지 않은 메서드나 속성은 부모 클래스의 정의를 참조한다.
따라서 부모 클래스의 메서드와 속성도 메모리에 로드되어 해당 클래스에서 저장된다.

## 상속시한 클래스를 조상타입으로 불러올 경우

Parent 클래스와 Child 클래스가 있다고 가정해보자.
child 클래스는 Parent 클래스를 상속한다.

우리는 다음과 같은 방법으로 child 클래스의 인스턴스를 생성할 수 있다.

```java
Parent p = new Child()
```
이때 인스턴스는 Heap 메모리 영역에 저장되며, 참조변수의 경우에는 스택 영역에 저장된다.

해당 인스턴스에서 Parent 클래스에 선언된 메서드를 실행시키려고 하면 자바는 다음의 과정을 거친다.

1. 메서드 호출시, JVM은 해당 클래스 타입의 메서드를 검색한다.
2. Parent를 통해 선언했기에 Parent 클래스에 작성된 메서드를 찾는다.
3. 메서드가 검색되면 해당 메서드의 코드가 실행된다. 메서드 코드는 클래스의 메서드 영역에 있으며, 메서드 호출 시 메모리 위치에 직접 접근하여 실행된다.

하지만 이때, 우리를 헷갈리게 하는 것은 다음과 같다.

조상 클래스의 메서드를 자손의 클래스에서 오버라이딩한 경우에, 참조변수의 타입에 상관 없이 항상 실제 인스턴스의 메서드가 호출 되는데, 참조 변수의 타입의 메서드를 검색한다고 했던 것에서 오류가 생기기 때문이다.

하지만 이때 자바 컴파일에서의 처리 과정은 다음과 같다.

1. **참조 변수의 타입에 해당하는 메서드 확인:** 먼저 참조 변수의 타입에 해당하는 클래스의 메서드를 확인한다. 이것은 컴파일러가 참조 변수의 타입을 기반으로 가능한 메서드 호출을 검사하는 단계입니다. 이 때 부모 클래스에 정의된 메서드가 호출 대상이 됩니다.
    
2. **실제 객체의 클래스 확인:** 런타임 시에는 실제 객체의 클래스를 확인합니다. 이것은 객체가 어떤 클래스의 인스턴스인지를 판단하는 단계다.
    
3. **오버라이딩된 메서드 호출:** 실제 객체의 클래스에서 오버라이딩된 메서드가 있는 경우에는 이 메서드가 호출됩니다. 따라서 부모 클래스의 메서드와 동일한 시그니처(이름, 매개변수 등)를 가진 자식 클래스의 메서드가 호출된다.


이러한 이유로 실제 인스턴스의 메서드가 호출 된다.

parent의 메서드 1이 있고
childe가 상속을 받아서 오버라이딩 
ㅑㅑㅑㅑㅑㅑㅑㅑㅑiiiiiiiii